import * as vscode from 'vscode';
import { InstructionId, SelectionState } from '../types';
import { getConfig } from './config';

async function readFileIfExists(uri: vscode.Uri): Promise<string | null> {
  try { return (await vscode.workspace.fs.readFile(uri)).toString(); }
  catch { return null; }
}

async function loadBlock(ctx: vscode.ExtensionContext, ws: vscode.WorkspaceFolder, id: InstructionId) {
  const { repoSetsDir } = getConfig();
  // 1) Repo override
  const repoUri = vscode.Uri.joinPath(ws.uri, repoSetsDir, `${id}.md`);
  const repoTxt = await readFileIfExists(repoUri);
  if (repoTxt) return repoTxt;

  // 2) Bundled template fallback
  const bundled = vscode.Uri.joinPath(ctx.extensionUri, 'media', 'templates', `${id}.md`);
  const bundledTxt = await readFileIfExists(bundled);
  return bundledTxt ?? `<!-- MISSING TEMPLATE: ${id} -->`;
}

export async function buildMergedContent(
  ctx: vscode.ExtensionContext,
  ws: vscode.WorkspaceFolder,
  sel: SelectionState,
  mappingHeader?: string
) {
  const order: InstructionId[] = [
    sel.base,
    ...sel.addOns.filter(x => x !== 'base-short' && x !== 'base-standard')
  ] as InstructionId[];

  const blocks = await Promise.all(order.map(id => loadBlock(ctx, ws, id)));
  const header =
`<!--
Generated by Copilot Instructions Composer
Base: ${sel.base}
Add-ons: ${sel.addOns.filter(x => !x.startsWith('base-')).join(', ') || '(none)'}
${mappingHeader ? `Mapping:\n${mappingHeader}` : ''}
-->`;

  return [header, ...blocks].join('\n\n---\n\n');
}
